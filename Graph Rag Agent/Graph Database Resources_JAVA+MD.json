{
  "name": "My workflow",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -3000,
        1035
      ],
      "id": "8858ce0c-0b47-4052-b0eb-db6d25900d5a",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "fileSelector": "/data/shared/Documents/**/*.{java,md}",
        "options": {
          "fileExtension": ""
        }
      },
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        -2780,
        1035
      ],
      "id": "dcd0acfe-a660-4c04-a769-ea3ff74877b9",
      "name": "Read/Write Files from Disk"
    },
    {
      "parameters": {
        "operation": "text",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -2560,
        1035
      ],
      "id": "a3d93b2f-3a59-4bc6-9386-10a11bcfaa5e",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "batchSize": 100,
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -1240,
        1035
      ],
      "id": "0ef4e800-e335-4faa-83e7-ab9c31a6905a",
      "name": "Loop Over Items"
    },
    {
      "parameters": {
        "command": "find  /data/shared/Documents/*"
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        -2120,
        1035
      ],
      "id": "e1bbb0e7-8446-45cb-8048-23b65e16e4c8",
      "name": "Execute Command"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "2e7f1c73-c82c-4343-a1a0-c0237d45eb6c",
              "name": "file_name",
              "value": "={{ $('Read/Write Files from Disk').item.json.fileName }}",
              "type": "string"
            },
            {
              "id": "c19c1443-6566-4046-9b3d-6e785eb6b66c",
              "name": "content",
              "value": "={{ $json.data }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -2340,
        1035
      ],
      "id": "e7cdeab7-a595-4e50-bbab-661dfed60756",
      "name": "Edit Fields1"
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first();\nconst stdout = item.json.stdout || \"\";\n\n// Étape 1: Extraire les lignes qui se terminent par .java ou .md\nconst lines = stdout\n  .split('\\n')\n  .map(line => line.trim())\n  .filter(line => line.endsWith('.java') || line.endsWith('.markdown') || line.endsWith('.md'));\n\n// Étape 2: Récupérer les items du node \"Edit Fields1\" de façon sécurisée\nlet editItems = [];\n\ntry {\n  const nodeItems = $('Edit Fields1').all();\n  for (const e of nodeItems) {\n    if (e && e.json) {\n      editItems.push(e.json);\n    }\n  }\n} catch (err) {\n  // En cas d'erreur, editItems restera vide\n  editItems = [];\n}\n\n// Étape 3: Construire les résultats\nconst results = [];\n\nfor (const line of lines) {\n  const fullPath = line;\n\n  // Chemin relatif\n  const relativePath = fullPath.replace('/data/shared/Documents/', '');\n\n  const parts = relativePath.split('/');\n  const fileName = parts.pop(); // le nom du fichier\n  const section = parts.join('/'); // dossier parent\n\n  // Chercher dans editItems celui qui correspond au fichier\n  const match = editItems.find(e => e.file_name === fileName);\n\n  results.push({\n    json: {\n      path: fullPath,\n      section: section,\n      file: fileName,\n      content: match ? match.content : null,\n      extractedAt: new Date().toISOString()\n    }\n  });\n}\n\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1900,
        1035
      ],
      "id": "e58c2fb2-453a-41fd-ac6e-4b09147e4525",
      "name": "Extract All informations"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "9c741488-67fd-4a13-8712-71e0c4eafb42",
              "name": "file_name",
              "value": "={{ $json.file }}",
              "type": "string"
            },
            {
              "id": "89f97c53-0a29-4f36-b33e-196d19dddfdc",
              "name": "section",
              "value": "={{ $json.section }}",
              "type": "string"
            },
            {
              "id": "59bed106-ad38-4ee1-b65e-01c2be5a7101",
              "name": "PATH",
              "value": "={{ $json.path }}",
              "type": "string"
            },
            {
              "id": "a5cbf09b-b7bd-4a6b-b9de-80a9e5103100",
              "name": "content",
              "value": "={{ $json.cleanedCode }}",
              "type": "string"
            },
            {
              "id": "3fc0295d-639d-494a-9a0b-e353f5ff1526",
              "name": "extracted",
              "value": "={{ $json.extractedAt }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1460,
        1035
      ],
      "id": "960dba03-0ba2-4514-a12e-f656dda67eca",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "resource": "graphDb",
        "cypherQuery": "={{ $('Create Batch+Cypher Query').item.json.cypherQuery }}"
      },
      "type": "n8n-nodes-neo4j.neo4j",
      "typeVersion": 1,
      "position": [
        -800,
        1035
      ],
      "id": "6388eaed-83c8-479c-a57d-6f76af4ac4df",
      "name": "Create Database",
      "credentials": {
        "neo4jApi": {
          "id": "XwdiNEDV42io6tPG",
          "name": "Neo4j account Cloud"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Lire la sortie du node 'create batch'\nconst allItems = $items(\"Create Batch+Cypher Query\", 0);\n\n// Supprimer le premier item (la query Cypher)\nconst onlyFiles = allItems.slice(1);\n\n// Retourner uniquement les fichiers (sans la query)\nreturn onlyFiles;\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -510,
        1110
      ],
      "id": "7493b05f-6565-4c18-b313-cddc3ee753a2",
      "name": "Return Items Seperated"
    },
    {
      "parameters": {
        "batchSize": "=1000",
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -800,
        635
      ],
      "id": "8a4b5a6a-c398-4806-97e4-d88077bdfb70",
      "name": "Loop Over Items2"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Analyze the following two files and define a relevant and general relationship between them.\nSource:\nFile: {{ $json.source.file }}\n\nPath: {{ $json.source.path }}\n\nSection: {{ $json.source.section }}\n\nContent: {{ $json.source.content }}\n\nTarget:\n\nFile: {{ $json.target.file }}\n\nPath: {{ $json.target.path }}\n\nSection: {{ $json.target.section }}\n\nContent: {{ $json.target.content }}\n\nDecision Criteria:\n\nIf both files belong to the same specific sub-section (e.g., computer_science/Huffman), consider them complementary, associated, or that one documents the other.\n\nIf the sections are different or general (e.g., computer_science vs mathematics), try to find a broad relationship like uses, influences, or compares.\n\nIf no relevant relationship exists, return type = \"different\" with a simple justification indicating that they deal with distinct topics.\n\nAlso analyze the content to confirm or refute the relationship.\n\nExpected Format (valid JSON):\n\njson\nCopier\nModifier\n{\n  \"source\": \"{{ $json.source.file }}\",\n  \"target\": \"{{ $json.target.file }}\",\n  \"type\": \"<relationship_type>\",\n  \"justification\": \"<concise_explanation>\",\n  \"source_section\": \"{{ $json.source.section }}\",\n  \"target_section\": \"{{ $json.target.section }}\"\n}",
        "options": {
          "systemMessage": "=You are an expert in source code analysis, technical document classification, and knowledge graph modeling.\nYour task is to identify relevant and general relationships between two files by analyzing their content, section, and technical nature.\n\nImportant rules:\n\nIf no meaningful relationship exists, return:\n\"type\": \"different\"\n\"justification\": \"The two files belong to different sections or concepts without a direct link.\"\n\nIf a relationship exists, choose a general type from:\ncomplementary, uses, documents, influences, compares, depends_on, associated.\n\nAvoid overly detailed or specific types (e.g., \"APPLICATION_AND_UNDERLYING_CONCURRENCY_MECHANISM\" → not allowed).\n\nThe justification must be clear but concise, explaining the general reason for the link (avoid overly long or technical analysis).\n\nBe neutral, factual, and structured."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        -580,
        640
      ],
      "id": "3c7654fb-a255-4e62-bb87-061a3adeb2d7",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -600,
        840
      ],
      "id": "dc1eba0f-2ef1-4ba7-8791-66418d0e6a10",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "rKtHTy7g6jG36Xzd",
          "name": "OpenAi account 2"
        }
      }
    },
    {
      "parameters": {
        "batchSize": 5000,
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -510,
        335
      ],
      "id": "fb1fd989-926c-43fc-abf4-04f35ba23c17",
      "name": "Loop Over Items3"
    },
    {
      "parameters": {
        "jsCode": "const batchItems = $input.all();\n\nconsole.log(`Génération requête pour batch de ${batchItems.length} items`);\n\nfunction escapeCypher(value) {\n  if (!value || typeof value !== 'string') return '';\n  \n  return value\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\"/g, '\\\\\"')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '')\n    .replace(/\\t/g, '\\\\t')\n    .substring(0, 8000);\n}\n\nconst mergeStatements = [];\n\nfor (let i = 0; i < batchItems.length; i++) {\n  const item = batchItems[i];\n\n  try {\n    if (!item.json.file_name || !item.json.PATH) {\n      console.warn(`Item ${i} ignoré: champs manquants`);\n      continue;\n    }\n\n    const fileName = escapeCypher(item.json.file_name);\n    const path = escapeCypher(item.json.PATH);\n    const content = escapeCypher(item.json.content);\n    const section = escapeCypher(item.json.section || '');\n    const extractedAt = item.json.extractedAT || new Date().toISOString();\n\n    const mergeStatement = `\nMERGE (d${i}:TestGraph1 {Source: \"${fileName}\", path: \"${path}\"}) \nON CREATE SET   \n  d${i}.content = \"${content}\",\n  d${i}.section = \"${section}\",\n  d${i}.extractedAt = \"${extractedAt}\",\n  d${i}.path = \"${path}\"\nON MATCH SET\n  d${i}.content = \"${content}\",\n  d${i}.section = \"${section}\",\n  d${i}.extractedAt = \"${extractedAt}\"`;\n\n    mergeStatements.push(mergeStatement);\n  } catch (error) {\n    console.error(`Erreur item ${i}:`, error.message);\n  }\n}\n\nconst cypherQuery = mergeStatements.join('\\n') +\n  `\\nRETURN ${mergeStatements.map((_, i) => `d${i}.Source as source${i}`).join(', ')}`;\n\nconsole.log(`Requête générée avec ${mergeStatements.length} MERGE statements`);\n\n// Sortie 1 : la requête Cypher\nconst queryOutput = {\n  json: {\n    cypherQuery,\n    batchSize: mergeStatements.length,\n    processedAt: new Date().toISOString()\n  }\n};\n\n// Sortie 2..n : les items originaux\nconst originalItemsOutput = batchItems;\n\nreturn [queryOutput, ...originalItemsOutput];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1020,
        1035
      ],
      "id": "9b0a228b-e4c9-4003-8f93-43af537dd3d7",
      "name": "Create Batch+Cypher Query"
    },
    {
      "parameters": {
        "jsCode": "const batchItems = $input.all();\nconsole.log(`Génération requête pour batch de ${batchItems.length} relations`);\n\nfunction escapeCypher(value) {\n  if (!value || typeof value !== 'string') return '';\n  \n  return value\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\"/g, '\\\\\"')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '')\n    .replace(/\\t/g, '\\\\t')\n    .substring(0, 8000);\n}\n\nconst mergeStatements = [];\nfor (let i = 0; i < batchItems.length; i++) {\n  const item = batchItems[i];\n  try {\n    // Vérification des champs requis\n    if (!item.json.source || !item.json.target || !item.json.relationshipType) {\n      console.warn(`Relation ${i} ignorée: champs manquants`);\n      continue;\n    }\n\n    // Échappement des valeurs\n    const source = escapeCypher(item.json.source);\n    const target = escapeCypher(item.json.target);\n    const sourceSection = escapeCypher(item.json.source_section || '');\n    const targetSection = escapeCypher(item.json.target_section || '');\n    const relationshipType = escapeCypher(item.json.relationshipType);\n    const justification = escapeCypher(item.json.justification || '');\n    const extractedAt = item.json.extractedAt || new Date().toISOString();\n\n    const mergeStatement = `\nMERGE (src${i}:TestGraph1 {Source: \"${source}\", section: \"${sourceSection}\"})\nMERGE (tgt${i}:TestGraph1 {Source: \"${target}\", section: \"${targetSection}\"})\nMERGE (src${i})-[rel${i}:\\`${relationshipType}\\`]->(tgt${i})\nON CREATE SET \n  rel${i}.justification = \"${justification}\",\n  rel${i}.source_section = \"${sourceSection}\",\n  rel${i}.target_section = \"${targetSection}\",\n  rel${i}.extractedAt = \"${extractedAt}\"\nON MATCH SET\n  rel${i}.justification = \"${justification}\",\n  rel${i}.extractedAt = \"${extractedAt}\"`;\n\n    mergeStatements.push(mergeStatement);\n  } catch (error) {\n    console.error(`Erreur relation ${i}:`, error.message);\n  }\n}\n\n// Construction de la requête finale avec RETURN\nconst cypherQuery = mergeStatements.join('\\n') +\n  `\\nRETURN ${mergeStatements.map((_, i) => `src${i}.Source as source${i}, type(rel${i}) as relType${i}, tgt${i}.Source as target${i}`).join(', ')}`;\n\nconsole.log(`Requête générée avec ${mergeStatements.length} relations MERGE statements`);\n\n// Sortie 1 : la requête Cypher\nconst queryOutput = {\n  json: {\n    cypherQuery,\n    batchSize: mergeStatements.length,\n    processedAt: new Date().toISOString(),\n    totalRelations: batchItems.length\n  }\n};\n\n// Sortie 2..n : les items originaux (relations)\n\n\nreturn queryOutput;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -220,
        260
      ],
      "id": "78c85cff-1c57-4e2a-9030-19e8d1f4e9dc",
      "name": "Create Cypher Query"
    },
    {
      "parameters": {
        "jsCode": "// Fonction de nettoyage pour Neo4j\nfunction cleanTextForCypher(text) {\n  if (!text) return \"\";\n  return text\n    .replace(/\\\\/g, '\\\\\\\\')   // Échapper \\\n    .replace(/\"/g, '\\\\\"')     // Échapper \"\n    .replace(/'/g, \"\\\\'\")     // Échapper '\n    .replace(/\\n/g, ' ')      // Remplacer retour ligne par espace\n    .replace(/\\r/g, ' ')      // Remplacer retour chariot\n    .replace(/\\t/g, ' ')      // Remplacer tabulation\n    .replace(/[\\x00-\\x1F\\x7F]/g, '') // Supprimer caractères de contrôle\n    .replace(/\\s+/g, ' ')     // Réduire les espaces multiples\n    .trim();\n}\n\n// Fonction pour traiter un seul item\nfunction processItem(item, index) {\n  try {\n    // Extraction de la sortie brute\n    const raw = item.json.output || \"\";\n    \n    // Nettoyage brut des balises Markdown (```json ou ```)\n    const cleaned = raw.replace(/```json|```/g, '').trim();\n    \n    // Parsing JSON\n    const parsed = JSON.parse(cleaned);\n    \n    // Nettoyage de la justification\n    const cleanedJustification = cleanTextForCypher(parsed.justification);\n    \n    // Construction du résultat pour cet item\n    return {\n      json: {\n        source: parsed.source,\n        target: parsed.target,\n        source_section: parsed.source_section,\n        target_section: parsed.target_section,\n        relationshipType: parsed.type,\n        justification: cleanedJustification,\n        extractedAt: new Date().toISOString(),\n        batchIndex: index // Optionnel : pour tracer l'ordre\n      }\n    };\n    \n  } catch (err) {\n    // En cas d'erreur, retourner un objet d'erreur\n    return {\n      json: {\n        error: true,\n        errorMessage: `Erreur item ${index}: ${err.message}`,\n        originalOutput: item.json.output,\n        extractedAt: new Date().toISOString(),\n        batchIndex: index\n      }\n    };\n  }\n}\n\n// Traitement de tous les items\nconst allItems = $input.all(); // Récupère TOUS les items du batch\nconst results = [];\n\n// Boucle sur chaque item\nfor (let i = 0; i < allItems.length; i++) {\n  const processedItem = processItem(allItems[i], i);\n  results.push(processedItem);\n}\n\n// Log pour debug (optionnel)\nconsole.log(`Traité ${results.length} items sur ${allItems.length} reçus`);\n\n// Retourner tous les résultats\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -220,
        640
      ],
      "id": "1f7b5b0e-cd4b-421d-b4cd-8d9d900294c3",
      "name": "Extract + Clean Justification"
    },
    {
      "parameters": {
        "jsCode": "const items = [];\n\nfor (const item of $input.all()) {\n  // Essayez d'abord content, sinon data\n  let rawCode = item.json.content || item.json.data;\n\n  // Vérifie que rawCode est une chaîne\n  if (typeof rawCode === 'string') {\n    try {\n      rawCode = rawCode\n        .replace(/^```(?:java)?/, '')  // Supprime ```java\n        .replace(/```$/, '')           // Supprime ```\n        .replace(/\\r/g, '')            // Supprime \\r\n        .trim();                       // Trim les espaces\n    } catch (e) {\n      // S'il y a une erreur inattendue, garde la valeur d'origine\n      rawCode = item.json.content || item.json.data;\n    }\n  } else {\n    // Si ce n’est pas une chaîne, ignore ou met chaîne vide\n    rawCode = '';\n  }\n\n  // Fonction d’échappement\n  const escapeJavaForCypher = (code) => {\n    return code\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g, '\\\\\"')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '');\n  };\n\n  const escapedCode = escapeJavaForCypher(rawCode);\n\n  items.push({\n    json: {\n      ...item.json,\n      cleanedCode: escapedCode,\n      extractedAt: new Date().toISOString()\n    }\n  });\n}\n\nreturn items;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1680,
        1035
      ],
      "id": "d8864ec2-347a-4430-9ca7-84e19e89cbc7",
      "name": "Bad Format Cleanup"
    },
    {
      "parameters": {
        "batchSize": 10000,
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -1020,
        785
      ],
      "id": "994a1bb8-d280-4e57-8d52-33c32e4898b4",
      "name": "Loop Over Items1"
    },
    {
      "parameters": {
        "jsCode": "const allFiles = $input.all().map(item => item.json);\nconst totalFiles = allFiles.length;\nconst maxPairsLimit = 50000; // Limite pour éviter surcharge mémoire\n\nconsole.log(`Génération optimisée pour ${totalFiles} fichiers (limite: ${maxPairsLimit})`);\n\nconst results = [];\nlet totalPairsGenerated = 0;\nconst totalPossiblePairs = totalFiles * (totalFiles - 1) / 2;\n\n// Si trop de paires possibles, utiliser échantillonnage\nconst useRandomSampling = totalPossiblePairs > maxPairsLimit;\nconst samplingRate = useRandomSampling ? maxPairsLimit / totalPossiblePairs : 1;\n\nconsole.log(`Mode: ${useRandomSampling ? 'Échantillonnage' : 'Complet'} (taux: ${samplingRate.toFixed(4)})`);\n\nfor (let i = 0; i < totalFiles - 1 && totalPairsGenerated < maxPairsLimit; i++) {\n  const currentFile = allFiles[i];\n  \n  for (let j = i + 1; j < totalFiles && totalPairsGenerated < maxPairsLimit; j++) {\n    const targetFile = allFiles[j];\n    \n    // Échantillonnage aléatoire si nécessaire\n    if (!useRandomSampling || Math.random() < samplingRate) {\n      results.push({\n        json: {\n          source: {\n            file: currentFile.file_name || currentFile.Source,\n            path: currentFile.PATH || currentFile.path,\n            section: currentFile.section,\n            content: currentFile.content\n          },\n          target: {\n            file: targetFile.file_name || targetFile.Source,\n            path: targetFile.PATH || targetFile.path,\n            section: targetFile.section,\n            content: targetFile.content\n          },\n          pairIndex: `${i + 1}-${j + 1}`,\n          sampled: useRandomSampling\n        }\n      });\n      \n      totalPairsGenerated++;\n    }\n  }\n  \n  // Log de progression\n  if (i % 10 === 0) {\n    console.log(`Itération ${i + 1}/${totalFiles - 1}: ${totalPairsGenerated} paires générées`);\n  }\n}\n\nconsole.log(`TERMINÉ: ${totalPairsGenerated} paires sur ${totalPossiblePairs} possibles`);\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -800,
        840
      ],
      "id": "a40faa12-218f-4aef-bd0c-76a47a91ad5f",
      "name": "Creating Relationships"
    },
    {
      "parameters": {
        "resource": "graphDb",
        "cypherQuery": "={{ $json.cypherQuery }}"
      },
      "type": "n8n-nodes-neo4j.neo4j",
      "typeVersion": 1,
      "position": [
        0,
        340
      ],
      "id": "f1e74242-ff47-409d-90ac-dce3e7a9dc3c",
      "name": "Create Relationships NEO4J",
      "credentials": {
        "neo4jApi": {
          "id": "XwdiNEDV42io6tPG",
          "name": "Neo4j account Cloud"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Read/Write Files from Disk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read/Write Files from Disk": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Edit Fields1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items": {
      "main": [
        [
          {
            "node": "Loop Over Items1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create Batch+Cypher Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Command": {
      "main": [
        [
          {
            "node": "Extract All informations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields1": {
      "main": [
        [
          {
            "node": "Execute Command",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract All informations": {
      "main": [
        [
          {
            "node": "Bad Format Cleanup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Database": {
      "main": [
        [
          {
            "node": "Return Items Seperated",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Return Items Seperated": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items2": {
      "main": [
        [
          {
            "node": "Loop Over Items3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Extract + Clean Justification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items3": {
      "main": [
        [],
        [
          {
            "node": "Create Cypher Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Batch+Cypher Query": {
      "main": [
        [
          {
            "node": "Create Database",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Cypher Query": {
      "main": [
        [
          {
            "node": "Create Relationships NEO4J",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract + Clean Justification": {
      "main": [
        [
          {
            "node": "Loop Over Items2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Bad Format Cleanup": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items1": {
      "main": [
        [
          {
            "node": "Loop Over Items2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Creating Relationships",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Creating Relationships": {
      "main": [
        [
          {
            "node": "Loop Over Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Relationships NEO4J": {
      "main": [
        [
          {
            "node": "Loop Over Items3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "4ac79af0-9788-4875-b057-182138f408b5",
  "meta": {
    "instanceId": "558d88703fb65b2d0e44613bc35916258b0f0bf983c5d4730c00c424b77ca36a"
  },
  "id": "1ms7aywFsDefNc5S",
  "tags": []
}